# 数据库结构更新建议

## 📋 问题分析

通过对比Java实体类和现有数据库结构，发现以下主要差异：

### 1. **数据类型不匹配**

| 表名 | 字段 | 数据库类型 | Java实体类型 | 问题 |
|------|------|-----------|-------------|------|
| `prescription` | `patient_gender` | `VARCHAR(10)` | `VARCHAR(20)` | 长度不够，可能导致数据截断 |
| `audit_record` | `audit_type` | `VARCHAR(20)` | `ENUM('auto','manual')` | 类型不匹配，存储了中文值 |
| `audit_record` | `audit_result` | `VARCHAR(20)` | `ENUM('pass','warning','reject')` | 类型不匹配，存储了中文值 |
| `stock_out` | `reason` | `VARCHAR(100)` | `ENUM('prescription','loss','expired','other')` | 类型不匹配，存储了中文值 |

### 2. **数据值不匹配**

- `audit_record` 表中存储的是中文值（"自动审核"、"通过"、"拒绝"等）
- Java代码期望的是英文ENUM值（"auto"、"pass"、"reject"等）
- 这已经导致运行时错误：`Data truncated for column 'audit_result' at row 1`

## ✅ 建议：**应该更新数据库结构**

### 理由：

1. **代码一致性**：Java实体类已经明确定义了ENUM类型，应该与数据库保持一致
2. **数据完整性**：使用ENUM可以确保数据的一致性和有效性
3. **避免运行时错误**：当前的结构不匹配已经导致实际运行中的错误
4. **更好的性能**：ENUM类型在数据库层面有更好的索引和查询性能
5. **维护性**：统一的代码-数据库结构更容易维护

## 🛠️ 更新方案

### 方案一：直接更新数据库结构（推荐）

**适用场景**：
- 测试环境或开发环境
- 已有测试数据可以重新导入
- 希望快速同步代码和数据库

**优点**：
- 简单直接
- 快速解决问题
- 符合最佳实践

**缺点**：
- 如果生产环境有重要数据，需要谨慎操作
- 需要数据迁移脚本

**操作步骤**：

1. 备份现有数据库（非常重要！）
   ```sql
   mysqldump -u root -p hpims > hpims_backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. 执行更新脚本
   ```sql
   -- 运行 database/update_schema.sql
   source database/update_schema.sql;
   ```

3. 验证更新结果
   ```sql
   -- 检查表结构
   DESCRIBE audit_record;
   DESCRIBE stock_out;
   DESCRIBE prescription;
   
   -- 检查数据转换是否正确
   SELECT audit_type, audit_result FROM audit_record;
   SELECT reason FROM stock_out;
   ```

### 方案二：保留现有数据，使用VARCHAR（不推荐）

**适用场景**：
- 生产环境有大量重要数据
- 短期内无法进行数据库迁移

**缺点**：
- 需要修改Java代码，在Service层进行值转换
- 代码和数据库不一致，增加维护成本
- 无法利用ENUM的数据完整性优势

## 📝 更新脚本说明

我已经创建了 `database/update_schema.sql` 脚本，该脚本会：

1. **扩展字段长度**：
   - `prescription.patient_gender`: VARCHAR(10) → VARCHAR(20)

2. **转换为ENUM类型**：
   - `audit_record.audit_type`: VARCHAR → ENUM('auto','manual')
   - `audit_record.audit_result`: VARCHAR → ENUM('pass','warning','reject')
   - `stock_out.reason`: VARCHAR → ENUM('prescription','loss','expired','other')

3. **数据迁移**：
   - 自动将中文值转换为对应的英文ENUM值
   - 保留所有现有数据

4. **数据转换映射**：

   **audit_type**：
   - "自动审核" → "auto"
   - "人工审核" → "manual"
   
   **audit_result**：
   - "通过"、"已通过" → "pass"
   - "警告" → "warning"
   - "拒绝"、"已拒绝" → "reject"
   - "待审核" → "pass"（默认）
   
   **reason**：
   - "处方发药" → "prescription"
   - "盘亏" → "loss"
   - "过期" → "expired"
   - "其他" → "other"

## ⚠️ 注意事项

### 执行前：

1. **备份数据库**（必须！）
   ```bash
   mysqldump -u root -p hpims > backup.sql
   ```

2. **检查现有数据**
   ```sql
   SELECT DISTINCT audit_type FROM audit_record;
   SELECT DISTINCT audit_result FROM audit_record;
   SELECT DISTINCT reason FROM stock_out;
   ```

3. **确保应用已停止**，避免在更新过程中有数据写入

### 执行后：

1. **验证数据转换**
   ```sql
   -- 检查是否有数据丢失
   SELECT COUNT(*) FROM audit_record;
   SELECT COUNT(*) FROM stock_out;
   
   -- 检查转换后的值
   SELECT audit_type, audit_result FROM audit_record LIMIT 10;
   SELECT reason FROM stock_out LIMIT 10;
   ```

2. **测试应用功能**
   - 测试处方创建
   - 测试审核功能
   - 测试发药功能

3. **更新测试数据**（如果使用 `init.sql`）
   - 更新 `init.sql` 中的测试数据，使用ENUM值而非中文

## 🔄 长期建议

### 1. 使用数据库迁移工具

建议使用 **Flyway** 或 **Liquibase** 来管理数据库版本：

- 版本控制数据库结构
- 自动执行迁移脚本
- 跟踪数据库变更历史

### 2. 统一命名规范

- 数据库存储：使用英文ENUM值（"pass", "auto"等）
- 前端显示：使用中文（"通过", "自动审核"等）
- 转换逻辑：在Java实体类中使用 `@JsonGetter` 进行序列化转换

### 3. 建立数据库文档

维护一个数据库结构文档，记录：
- 每个表的结构
- ENUM字段的可选值
- 字段的业务含义

## ✅ 总结

**强烈建议更新数据库结构**，理由：
1. 代码已经明确使用ENUM类型
2. 当前结构已经导致运行时错误
3. 使用ENUM有更好的数据完整性和性能
4. 更新的影响是可控的（有完整的迁移脚本）

**建议操作顺序**：
1. 备份数据库
2. 在测试环境先执行更新脚本
3. 验证功能正常
4. 在生产环境执行（如果测试通过）

执行更新后，您的Java代码和数据库结构将完全一致，不会再出现数据类型不匹配的问题。

